#!/usr/bin/env python3

import argparse
import os
import re
import sys
from collections.abc import Iterable
from dataclasses import asdict, dataclass, field
from pathlib import Path
from typing import Any

from bson.objectid import ObjectId
from gridfs import GridFS
from pymongo import MongoClient
from pymongo.database import Database

MONGO_URI = os.getenv("MONGO_URI", "mongodb://localhost:30017/music")


@dataclass
class Score:
    _id: ObjectId = field(default_factory=ObjectId)
    simple_name: str | None = None
    title: str | None = None
    composer: str | None = None
    time: list[str] = field(default_factory=list)
    key: list[str] = field(default_factory=list)
    engraving_id: ObjectId | None = None
    subtitle: str | None = None


@dataclass
class Engraving:
    _id: ObjectId = field(default_factory=ObjectId)
    score_id: ObjectId | None = None
    engraving: ObjectId | None = None


def _get_score_metadata(path: Path) -> Score:
    if not path.is_dir():
        raise ValueError(f"{path} is not a directory")

    score = Score()
    score.simple_name = path.stem
    metadata_re = re.compile(r"\s+\\?(title|subtitle|composer|time|key)(\s+=)?\s+(.*)")
    files = list(path.glob("**/*.ly"))

    if not files:
        raise ValueError(f"No Lilypond source files found in '{path}'")

    for file in files:
        with open(file, "r") as src:
            for line in src:
                match = metadata_re.match(line)

                if match:
                    k = match.group(1)
                    v = match.group(3).strip().strip("'\"")

                    if isinstance(getattr(score, k), list):
                        getattr(score, k).append(v)
                    else:
                        setattr(score, k, v)

    score.key = [k.replace("\\", "").title() for k in score.key]

    return score


def _get_engraving(path: Path, score: Score, fs: GridFS) -> Engraving:
    engraving = Engraving()
    engraving_file = (
        path.parent.parent / "engravings" / ((score.title or "unknown") + ".pdf")
    )

    if not engraving_file.exists():
        raise ValueError(f"'{engraving_file}' does not exist")

    with open(engraving_file, "rb") as pdf:
        data = pdf.read()

    file_id = fs.put(data, filename=engraving_file.name)
    engraving.engraving = file_id

    return engraving


def get_score_data(path: Path, fs: GridFS) -> tuple[Score, Engraving]:
    score = _get_score_metadata(path)
    engraving = _get_engraving(path, score, fs)
    score.engraving_id = engraving._id
    engraving.score_id = score._id

    return score, engraving


def get_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser()

    parser.add_argument("path", nargs="?", help="Path to directory containing score")
    parser.add_argument(
        "-d", "--score-dir", help="Path to directory containing multiple scores"
    )

    return parser


def commit(
    db: Database, scores: Iterable[dict[str, Any]], engravings: Iterable[dict[str, Any]]
) -> None:
    db.scores.insert_many(scores)
    db.engravings.insert_many(engravings)


def main() -> None:
    parser = get_parser()
    args = parser.parse_args()
    path = Path(args.path) if args.path else None
    score_repo = Path(args.score_dir) if args.score_dir else None

    if path is None and score_repo is None:  # style here is to appease mypy
        sys.exit("Either 'path' or '--score-dir' must be provided")

    if path and score_repo:
        sys.exit("Only one of 'path' or '--score-dir' should be provided")

    client: MongoClient = MongoClient(MONGO_URI)
    db = client.get_database()
    fs = GridFS(db)
    metadata = list()
    data = list()

    score_sources = (
        [path]
        if path is not None
        else [d for d in score_repo.iterdir() if d.stem != "with-fingering"]
        if score_repo is not None
        else []
    )

    for src_dir in score_sources:
        score, engraving = get_score_data(src_dir, fs)

        metadata.append(asdict(score))
        data.append(asdict(engraving))

        print(f"{score.simple_name}: engraving_id {str(engraving._id)}")

    commit(db, metadata, data)
    client.close()


if __name__ == "__main__":
    main()
